Я сделал таблицу с автоматически изменяемым размером буфера,
поэтому интерфейс несколько отличается от ответа.

Во-первых, у конструктора есть два дополнительных параметра:
1) минимальный допустимый размер таблицы (по умолчанию - исходный размер);
2) максимальное допустимое количество коллизий.
Кроме этого, размер таблицы всегда простое число, 
и изначальный размер всегда не меньше, чем указано при вызове конструктора.

Во-вторых, нет предусловия наличия свободного слота.
Таблица расширяется, если она переполнена (для маленьких таблиц),
или превышено максимальное количество коллизий (для больших таблиц),
чтобы сохранить сложность поиска O(1).
Если в таблице очень мало значений, то для экономии памяти она сжимается.

При изменении размера значения из старой таблицы копируются в новую.
Если лимит коллизий при этом всё равно превышен,
то процесс повторяется с другими хэш функциями пока не повезёт.
На практике (в тестах) мне хватало двух попыток, и повтор требовался для таблиц
с десятками и сотнями тысяч значений.

Размер таблицы - всегда простое число.
Для поиска и кэширования простых размеров используется отдельный АТД PrimeScales,
спроектированный в духе данного курса: с командами, запросами, статусами,
пред- и постусловиями.

При поиске простых чисел используется АТД PrimeTester,
который помнит и пополняет список простых множителей для ускорения проверки.

Внутри таблицы используется АТД HashBuffer, который является наледником АТД Buffer.

АТД Buffer - фактически массив постоянного размера, в котором могут быть
"пустые" и "удалённые" значения.

АТД HashBuffer добавляет запрос для поиска слота, подходящего под значение.
Результатом поиска может быть найденное значение, пустой слот для него,
или превышение лимита коллизий.

За генерацию индексов для поиска отвечает АТД HashIterator
(используется внутри HashBuffer), при создании которого коэффициенты хэш-функций
задаются с помощью генератора псевдослучайных чисел из стандартной библиотеки.
